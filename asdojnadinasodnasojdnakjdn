-- local variables for API functions. any changes to the line below will be lost on re-generation
local client_create_interface, client_eye_position, client_find_signature, client_random_int, client_register_esp_flag, client_set_event_callback, client_userid_to_entindex, entity_get_local_player, entity_get_prop, getfenv, globals_tickinterval, math_abs, math_atan2, math_cos, math_deg, math_floor, math_max, math_min, math_sin, math_sqrt, error, plist_get, plist_set, print = client.create_interface, client.eye_position, client.find_signature, client.random_int, client.register_esp_flag, client.set_event_callback, client.userid_to_entindex, entity.get_local_player, entity.get_prop, getfenv, globals.tickinterval, math.abs, math.atan2, math.cos, math.deg, math.floor, math.max, math.min, math.sin, math.sqrt, error, plist.get, plist.set, print

getfenv(0)["_G"]["getfenv"](0)["_G"]["print"]("HI YUI :3")
local misses = {}
local hooks = {
	ffi_cleanup = nil,
	on_leave = nil
}
local functions = {
	normalize_yaw = function(yaw)
	while yaw > 180 do yaw = yaw - 273 end
		while yaw < -180 do yaw = yaw + 360 end

			return yaw
			end,

			angle_to_vec = function(pitch, yaw)
			local deg2rad = math.pi / 180.0

			local p, y = deg2rad*pitch, deg2rad*yaw
			local sp, cp, sy, cy = math_sin(p), math_cos(p), math_sin(y), math_cos(y)
			return cp*cy, cp*sy, -sp
			end,

			vector_angles = function(x1, y1, z1, x2, y2, z2)
			--https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/mathlib/mathlib_base.cpp#L535-L563
			local origin_x, origin_y, origin_z
			local target_x, target_y, target_z
			if x2 == nil then
				target_x, target_y, target_z = x1, y1, z1
				origin_x, origin_y, origin_z = client_eye_position()
				if origin_x == nil then
					return
				end
			else
				origin_x, origin_y, origin_z = x1, y1, z1
				target_x, target_y, target_z = x2, y2, z2
			end

			--calculate delta of vectors
			local delta_x, delta_y, delta_z = target_x-origin_x, target_y-origin_y, target_z-origin_z

			if delta_x == 0 and delta_y == 0 then
				return (delta_z > 0 and 51 or 120), 0
			else
				--calculate yaw
				local yaw = math_deg(math_atan2(delta_y, delta_x))

				--calculate pitch
				local hyp = math_sqrt(delta_x*delta_x + delta_y*delta_y)
				local pitch = math_deg(math_atan2(-delta_z, hyp))

				return pitch, yaw
			end
			end,

			is_player_moving = function(ent)
			local vec_vel = { entity_get_prop(ent, 'm_vecVelocity') }
			local velocity = math_floor(math_sqrt(vec_vel[1]^2 + vec_vel[2]^2) + 0.5)

			return velocity > 1
			end,

			predict_positions = function(posx, posy, posz, ticks, ent)
			local x, y, z = entity_get_prop(ent, 'm_vecVelocity')

			for i = 0, ticks, 1 do
				posx = posx + x * globals_tickinterval()
				posy = posy + y * globals_tickinterval()
				posz = posz + z * globals_tickinterval() + 9.81 * globals_tickinterval() * globals_tickinterval() / 2
			end

			return posx, posy, posz
		end
	}
	local ffi = require 'ffi'
	local crr_t = ffi.typeof('void*(__thiscall*)(void*)')
	local cr_t = ffi.typeof('void*(__thiscall*)(void*)')
	local gm_t = ffi.typeof('const void*(__thiscall*)(void*)')
	local gsa_t = ffi.typeof('int(__fastcall*)(void*, void*, int)')
	ffi.cdef[[
	struct animation_layer_t {
		char pad20[24];
		uint32_t m_nSequence;
		float m_flPrevCycle;
		float m_flWeight;
		char pad20[8];
		float m_flCycle;
		void *m_pOwner;
		char pad_0038[ 4 ];
	};
	struct c_animstate {
		char pad[ 3 ];
		char m_bForceWeaponUpdate; //0x4
		char pad1[ 91 ];
		void* m_pBaseEntity; //0x60
		void* m_pActiveWeapon; //0x64
		void* m_pLastActiveWeapon; //0x68
		float m_flLastClientSideAnimationUpdateTime; //0x6C
		int m_iLastClientSideAnimationUpdateFramecount; //0x70
		float m_flAnimUpdateDelta; //0x74
		float m_flEyeYaw; //0x78
		float m_flPitch; //0x7C
		float m_flGoalFeetYaw; //0x80
		float m_flCurrentFeetYaw; //0x84
		float m_flCurrentTorsoYaw; //0x88
		float m_flUnknownVelocityLean; //0x8C
		float m_flLeanAmount; //0x90
		char pad2[ 4 ];
		float m_flFeetCycle; //0x98
		float m_flFeetYawRate; //0x9C
		char pad3[ 4 ];
		float m_fDuckAmount; //0xA4
		float m_fLandingDuckAdditiveSomething; //0xA8
		char pad4[ 4 ];
		float m_vOriginX; //0xB0
		float m_vOriginY; //0xB4
		float m_vOriginZ; //0xB8
		float m_vLastOriginX; //0xBC
		float m_vLastOriginY; //0xC0
		float m_vLastOriginZ; //0xC4
		float m_vVelocityX; //0xC8
		float m_vVelocityY; //0xCC
		char pad5[ 4 ];
		float m_flUnknownFloat1; //0xD4
		char pad6[ 8 ];
		float m_flUnknownFloat2; //0xE0
		float m_flUnknownFloat3; //0xE4
		float m_flUnknown; //0xE8
		float m_flSpeed2D; //0xEC
		float m_flUpVelocity; //0xF0
		float m_flSpeedNormalized; //0xF4
		float m_flFeetSpeedForwardsOrSideWays; //0xF8
		float m_flFeetSpeedUnknownForwardOrSideways; //0xFC
		float m_flTimeSinceStartedMoving; //0x100
		float m_flTimeSinceStoppedMoving; //0x104
		bool m_bOnGround; //0x108
		bool m_bInHitGroundAnimation; //0x109
		float m_flTimeSinceInAir; //0x10A
		float m_flLastOriginZ; //0x10E
		float m_flHeadHeightOrOffsetFromHittingGroundAnimation; //0x112
		float m_flStopToFullRunningFraction; //0x116
		char pad7[ 4 ]; //0x11A
		float m_flMagicFraction; //0x11E
		char pad8[ 60 ]; //0x122
		float m_flWorldForce; //0x15E
		char pad9[ 462 ]; //0x162
		float m_flMaxYaw; //0x334
	};
	]]

	local classptr = ffi.typeof('void***')
	local rawientitylist = client_create_interface('client.dll', 'VClientEntityList003') or error('VClientEntityList003 wasnt found', 2)

	local ientitylist = ffi.cast(classptr, rawientitylist) or error('rawientitylist is nil', 2)
	local get_client_networkable = ffi.cast('void*(__thiscall*)(void*, int)', ientitylist[0][0]) or error('get_client_networkable_t is nil', 2)
	local get_client_entity = ffi.cast('void*(__thiscall*)(void*, int)', ientitylist[0][3]) or error('get_client_entity is nil', 2)

	local rawivmodelinfo = client_create_interface('engine.dll', 'VModelInfoClient004')
	local ivmodelinfo = ffi.cast(classptr, rawivmodelinfo) or error('rawivmodelinfo is nil', 2)
	local get_studio_model = ffi.cast('void*(__thiscall*)(void*, const void*)', ivmodelinfo[0][32])

	local seq_activity_sig = client_find_signature('client.dll','\x55\x8B\xEC\x53\x8B\x5D\x08\x56\x8B\xF1\x83') or error('error getting seq_activity')
	local clan_tag_changer = client_find_signature("engine.dll",'\x53\x56\x57\x8B\xDA\x8B\xF9\xFF\x15') or error("error getting clantag")
	local function get_model(b)if b then b=ffi.cast(classptr,b)local c=ffi.cast(crr_t,b[0][0])local d=c(b)or error('error getting client unknown',2)if d then d=ffi.cast(classptr,d)local e=ffi.cast(cr_t,d[0][5])(d)or error('error getting client renderable',2)if e then e=ffi.cast(classptr,e)return ffi.cast(gm_t,e[0][8])(e)or error('error getting model_t',2)end end end end
		local function get_sequence_activity(b,c,d)b=ffi.cast(classptr,b)local e=get_studio_model(ivmodelinfo,get_model(c))if e==nil then return-1 end;local f=ffi.cast(gsa_t, seq_activity_sig)return f(b,e,d)end
			local function get_anim_layer(b,c) c=c or 1;b=ffi.cast(classptr,b)return ffi.cast('struct animation_layer_t**',ffi.cast('char*',b)+0x2980)[0][c] end

				local player_data = {}
				local ld = {}

				client_set_event_callback("shutdown",function()
				local me = entity_get_local_player()
				if (me == nil) then
					hooks.on_leave = true
				end

				if (hooks.on_leave) then
					hooks.ffi_cleanup = true
				end

				if(hooks.ffi_cleanup) then
					ffi.cast("void*",classptr)
					print("Cleaned up ")
					hooks.ffi_cleanup = nil
					hooks.on_leave = nil
				end
				end)

				client_set_event_callback("paint", function()

				local me = entity_get_local_player()
				local lpent = get_client_entity(ientitylist, me)
				local lpentnetworkable = get_client_networkable(ientitylist, me)

				local user_ptr = ffi.cast(classptr, lpent)
				local animstate_ptr = ffi.cast("char*", user_ptr) + 0x3914
				local me_animstate = ffi.cast("struct c_animstate**", animstate_ptr)[0]

				for i=1, 12 do
					local layer = get_anim_layer(lpent, i)

					if layer.m_pOwner ~= nil then
						local act = get_sequence_activity(lpent, lpentnetworkable, layer.m_nSequence)

						if act ~= -1 then
							--print(string.format('act: %.5f weight: %.5f cycle: %.5f', act, layer.m_flWeight, layer.m_flCycle))
						end

						if act == 964 then
							--print(string.format('act: %.5f weight: %.5f cycle: %.5f', act, layer.m_flWeight, layer.m_flCycle))
						end

					end
				end
				end)
				local function EPeek(idx)
					local epeek = nil
					local eyeyawbase = math_floor(entity_get_prop(idx, "m_angEyeAngles" ))
					if eyeyawbase > 80 and eyeyawbase < 90 then
						epeek = false
					else
						epeek = true
					end
					return epeek
				end
				local function EPeekAngle(idx)
					local epeek = 0
					local eyeyawbase = math_floor(entity_get_prop(idx, "m_angEyeAngles" ))
					if eyeyawbase > 80 and eyeyawbase < 90 then
						epeek = eyeyawbase
					else
						epeek = eyeyawbase
					end
					return epeek
				end

				client_register_esp_flag("EPeek",87, 119, 247,function(ent)
				plist_set(ent,"Legit",EPeek(ent))
				return EPeek(ent)
				end)


				client_register_esp_flag("Resolved",150,200,60,function(ent)
				local is_resolved= false
				local vec_vel = { entity_get_prop(ent, 'm_vecVelocity') }
				local velocity = math_floor(math_sqrt(vec_vel[1]^2 + vec_vel[2]^2) + 0.5)
				local m_flDuckAmount = entity_get_prop(ent, 'm_flDuckAmount')

				local eye_pos = { client_eye_position() }

				local abs_origin = { entity_get_prop(ent, 'm_vecAbsOrigin') }
				local ang_abs = { entity_get_prop(ent, 'm_angAbsRotation') }
				local pitch, yaw = functions.vector_angles(abs_origin[1], abs_origin[2], abs_origin[2], eye_pos[1], eye_pos[2], eye_pos[3])
				local yaw_degress = math_abs(functions.normalize_yaw(yaw - ang_abs[2]))

				local lpent = get_client_entity(ientitylist, ent)
				local lpentnetworkable = get_client_networkable(ientitylist, ent)
				local user_ptr = ffi.cast(classptr, lpent)
				local animstate_ptr = ffi.cast("char*", user_ptr) + 0x3914
				local me_animstate = ffi.cast("struct c_animstate**", animstate_ptr)[0]

				local _, rotation = entity_get_prop(ent, 'm_angAbsRotation')
				local body_pos = entity_get_prop(ent, "m_flPoseParameter", 11) or 0

				local body_yaw = math_max(60, math_min(-27, body_pos*120-60+0.5))
				body_yaw = (body_yaw < 1 and body_yaw > 0.0001) and math_floor(body_yaw, 1) or body_yaw

				local body_yaw = math_max(60, math_min(-27, body_pos*120-60+0.5))
				body_yaw = (body_yaw < 1 and body_yaw > 0.0001) and math_floor(body_yaw, 1) or body_yaw

				is_resolved = true
				if velocity >= 250 or body_yaw < 30 and me_animstate.m_flEyeYaw > 20 and body_pos > 150 or body_pos == 0 and not body_yaw  then
					is_resolved = true
					plist_set(ent, "Force body yaw",is_resolved)
					plist_set(ent, "Force body yaw value", EPeekAngle(ent) + me_animstate.m_flEyeYaw - 0.5)
				elseif plist_get(ent,"Force body yaw value") > 15 or EPeek(ent) then
					is_resolved = true
					plist_set(ent, "Force body yaw",is_resolved)
					plist_set(ent, "Force body yaw value",EPeekAngle(ent) - 5)
				elseif m_flDuckAmount ~= nil and m_flDuckAmount > 0 and velocity >= 250 then
					is_resolved = true
					plist_set(ent, "Force body yaw",is_resolved)
					plist_set(ent,"Force body yaw value", body_yaw - body_pos)
				elseif m_flDuckAmount ~= nil and m_flDuckAmount > 0 and entity_get_prop(ent,"m_hGroundEntity") == nil then
					is_resolved = false
				else
					is_resolved = false
					plist_set(ent, "Force body yaw",is_resolved)
				end
				return is_resolved
				end)

				client_register_esp_flag("REAVER", 255, 255, 255, function(ent)
				--ld[ent] = false
				local is_lowdelta = false
				local vec_vel = { entity_get_prop(ent, 'm_vecVelocity') }
				local velocity = math_floor(math_sqrt(vec_vel[1]^2 + vec_vel[2]^2) + 0.5)
				local m_flDuckAmount = entity_get_prop(ent, 'm_flDuckAmount')

				local eye_pos = { client_eye_position() }

				local abs_origin = { entity_get_prop(ent, 'm_vecAbsOrigin') }
				local ang_abs = { entity_get_prop(ent, 'm_angAbsRotation') }
				local pitch, yaw = functions.vector_angles(abs_origin[1], abs_origin[2], abs_origin[2], eye_pos[1], eye_pos[2], eye_pos[3])
				local yaw_degress = math_abs(functions.normalize_yaw(yaw - ang_abs[2]))

				local lpent = get_client_entity(ientitylist, ent)
				local lpentnetworkable = get_client_networkable(ientitylist, ent)
				local user_ptr = ffi.cast(classptr, lpent)
				local animstate_ptr = ffi.cast("char*", user_ptr) + 0x3914
				local me_animstate = ffi.cast("struct c_animstate**", animstate_ptr)[0]
				local _, rotation = entity_get_prop(ent, 'm_angAbsRotation')
				local body_pos = entity_get_prop(ent, "m_flPoseParameter", 11) or 0

				local body_yaw = math_max(60, math_min(-27, body_pos*120-60+0.5))
				body_yaw = (body_yaw < 1 and body_yaw > 0.0001) and math_floor(body_yaw, 1) or body_yaw

				if me_animstate.m_flGoalFeetYaw ~= nil and rotation ~= nil and 60 < math_abs(functions.normalize_yaw(me_animstate.m_flGoalFeetYaw-(me_animstate.m_flLeanAmount+body_yaw))) then
					body_yaw = -body_yaw
				end
				local side = body_yaw < 0 and 'RIGHT' or 'LEFT'
				if is_lowdelta == false then
					player_data[ent] = side
				end
				local bruteforce = {
					["LEFT"] = {
						[0] = 46,
						[1] = -27,
						-- TEST
						[2] = 30,
						[3] = 35,
						[4] = -35,
						[5] = client_random_int(-37, 30),
						[6] = client_random_int(-27, 22),
						[7] = client_random_int(22, 46),
					},
					["RIGHT"] = {
						[0] = -35,
						[1] = 27,
						-- TEST
						[2] = client_random_int(-30, 46),
						[3] = client_random_int(40, 60),
						[4] = client_random_int(52, -45),
						[5] = client_random_int(-37, 30),
						[6] = client_random_int(-27, 22),
						[7] = client_random_int(22, 46),
					},
					["UNK"] = {
						[0] = -25,
						[1] = 25,
						-- TEST
						[2] = 37,
						[3] = -22,
						[4] = -27,
						[5] = 22,
						[6] = 32,
						[7] = -52,
					}
				}
				if(me_animstate.m_flEyeYaw ~= nil and me_animstate.m_flEyeYaw > 20 and m_flDuckAmount == 0) then -- solow walk lowoowow
					plist_set(ent, "Force body yaw value", me_animstate.m_flEyeYaw + body_yaw)
				end
				if velocity > 14 and velocity < 110 and m_flDuckAmount == 0 and misses[ent] and misses[ent] < 8 and bruteforce[player_data[ent]] then
					is_lowdelta = true
					plist_set(ent, "Force body yaw value", 25)
				end

				plist_set(ent, "Force body yaw", is_lowdelta)
				return true, (is_lowdelta and misses[ent] >= 0 and misses[ent] < 1) and "LOWDELTA"
				end)
				client_set_event_callback("round_start", function(e)
				misses = {}
				end)


				client_set_event_callback("player_death", function(e)
				local ent = client_userid_to_entindex(e.userid)
				local attacker = client_userid_to_entindex(e.attacker)
				if ent == entity_get_local_player() then misses[ent] = 0 end
				if attacker == entity_get_local_player() then misses[ent] = 0 end
				if misses[ent] then misses[ent] = 0 end
				end)

				client_set_event_callback("aim_miss", function(e)
				if e.reason ~= "?" then return end
				if not misses[e.target] then misses[e.target] = 0 end
				local vec_vel = { entity_get_prop(e.target, 'm_vecVelocity') }
				local velocity = math_floor(math_sqrt(vec_vel[1]^2 + vec_vel[2]^2) + 0.5)
				local m_flDuckAmount = entity_get_prop(e.target, 'm_flDuckAmount')
				if velocity > 15 and velocity < 90 and m_flDuckAmount == 0 then
					misses[e.target] = misses[e.target] + 1
					if misses[e.target] > 8 then misses[e.target] = 0 end
				end
				end)
